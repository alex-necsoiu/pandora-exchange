// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_logs.sql

package postgres

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditLogsByCategory = `-- name: CountAuditLogsByCategory :one
SELECT COUNT(*) FROM audit_logs
WHERE event_category = $1
`

func (q *Queries) CountAuditLogsByCategory(ctx context.Context, eventCategory string) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByCategory, eventCategory)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByEventType = `-- name: CountAuditLogsByEventType :one
SELECT COUNT(*) FROM audit_logs
WHERE event_type = $1
`

func (q *Queries) CountAuditLogsByEventType(ctx context.Context, eventType string) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByEventType, eventType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByUser = `-- name: CountAuditLogsByUser :one
SELECT COUNT(*) FROM audit_logs
WHERE user_id = $1
`

func (q *Queries) CountAuditLogsByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchAuditLogs = `-- name: CountSearchAuditLogs :one
SELECT COUNT(*) FROM audit_logs
WHERE 
    ($1::uuid IS NULL OR user_id = $1) AND
    ($2::varchar IS NULL OR event_type = $2) AND
    ($3::varchar IS NULL OR event_category = $3) AND
    ($4::varchar IS NULL OR severity = $4) AND
    ($5::timestamptz IS NULL OR created_at >= $5) AND
    ($6::timestamptz IS NULL OR created_at <= $6)
`

type CountSearchAuditLogsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Column6 time.Time `json:"column_6"`
}

func (q *Queries) CountSearchAuditLogs(ctx context.Context, arg CountSearchAuditLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchAuditLogs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
    event_type,
    event_category,
    severity,
    user_id,
    actor_type,
    actor_identifier,
    action,
    resource_type,
    resource_id,
    ip_address,
    user_agent,
    request_id,
    session_id,
    metadata,
    previous_state,
    new_state,
    status,
    failure_reason,
    retention_until,
    is_sensitive
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
) RETURNING id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at
`

type CreateAuditLogParams struct {
	EventType       string             `json:"event_type"`
	EventCategory   string             `json:"event_category"`
	Severity        string             `json:"severity"`
	UserID          pgtype.UUID        `json:"user_id"`
	ActorType       string             `json:"actor_type"`
	ActorIdentifier *string            `json:"actor_identifier"`
	Action          string             `json:"action"`
	ResourceType    *string            `json:"resource_type"`
	ResourceID      *string            `json:"resource_id"`
	IpAddress       *netip.Addr        `json:"ip_address"`
	UserAgent       *string            `json:"user_agent"`
	RequestID       *string            `json:"request_id"`
	SessionID       *string            `json:"session_id"`
	Metadata        []byte             `json:"metadata"`
	PreviousState   []byte             `json:"previous_state"`
	NewState        []byte             `json:"new_state"`
	Status          string             `json:"status"`
	FailureReason   *string            `json:"failure_reason"`
	RetentionUntil  pgtype.Timestamptz `json:"retention_until"`
	IsSensitive     *bool              `json:"is_sensitive"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.EventType,
		arg.EventCategory,
		arg.Severity,
		arg.UserID,
		arg.ActorType,
		arg.ActorIdentifier,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.IpAddress,
		arg.UserAgent,
		arg.RequestID,
		arg.SessionID,
		arg.Metadata,
		arg.PreviousState,
		arg.NewState,
		arg.Status,
		arg.FailureReason,
		arg.RetentionUntil,
		arg.IsSensitive,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.EventCategory,
		&i.Severity,
		&i.UserID,
		&i.ActorType,
		&i.ActorIdentifier,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.IpAddress,
		&i.UserAgent,
		&i.RequestID,
		&i.SessionID,
		&i.Metadata,
		&i.PreviousState,
		&i.NewState,
		&i.Status,
		&i.FailureReason,
		&i.RetentionUntil,
		&i.IsSensitive,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredAuditLogs = `-- name: DeleteExpiredAuditLogs :exec
DELETE FROM audit_logs
WHERE retention_until IS NOT NULL
  AND retention_until < NOW()
`

func (q *Queries) DeleteExpiredAuditLogs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAuditLogs)
	return err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE id = $1
`

func (q *Queries) GetAuditLogByID(ctx context.Context, id uuid.UUID) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.EventCategory,
		&i.Severity,
		&i.UserID,
		&i.ActorType,
		&i.ActorIdentifier,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.IpAddress,
		&i.UserAgent,
		&i.RequestID,
		&i.SessionID,
		&i.Metadata,
		&i.PreviousState,
		&i.NewState,
		&i.Status,
		&i.FailureReason,
		&i.RetentionUntil,
		&i.IsSensitive,
		&i.CreatedAt,
	)
	return i, err
}

const getFailedLoginAttempts = `-- name: GetFailedLoginAttempts :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE event_type = 'user.login.failed'
  AND user_id = $1
  AND created_at >= NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC
`

func (q *Queries) GetFailedLoginAttempts(ctx context.Context, userID pgtype.UUID) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttempts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentSecurityEvents = `-- name: GetRecentSecurityEvents :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE event_category = 'security'
  AND severity IN ('high', 'critical')
  AND created_at >= NOW() - INTERVAL '24 hours'
ORDER BY created_at DESC
`

func (q *Queries) GetRecentSecurityEvents(ctx context.Context) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getRecentSecurityEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByCategory = `-- name: ListAuditLogsByCategory :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE event_category = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByCategoryParams struct {
	EventCategory string `json:"event_category"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsByCategory(ctx context.Context, arg ListAuditLogsByCategoryParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByCategory, arg.EventCategory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByDateRange = `-- name: ListAuditLogsByDateRange :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) ListAuditLogsByDateRange(ctx context.Context, arg ListAuditLogsByDateRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByEventType = `-- name: ListAuditLogsByEventType :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE event_type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByEventTypeParams struct {
	EventType string `json:"event_type"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsByEventType(ctx context.Context, arg ListAuditLogsByEventTypeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByEventType, arg.EventType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByIPAddress = `-- name: ListAuditLogsByIPAddress :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE ip_address = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByIPAddressParams struct {
	IpAddress *netip.Addr `json:"ip_address"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListAuditLogsByIPAddress(ctx context.Context, arg ListAuditLogsByIPAddressParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByIPAddress, arg.IpAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByResource = `-- name: ListAuditLogsByResource :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE resource_type = $1 AND resource_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByResourceParams struct {
	ResourceType *string `json:"resource_type"`
	ResourceID   *string `json:"resource_id"`
	Limit        int32   `json:"limit"`
	Offset       int32   `json:"offset"`
}

func (q *Queries) ListAuditLogsByResource(ctx context.Context, arg ListAuditLogsByResourceParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByResource,
		arg.ResourceType,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsBySeverity = `-- name: ListAuditLogsBySeverity :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE severity = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsBySeverityParams struct {
	Severity string `json:"severity"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListAuditLogsBySeverity(ctx context.Context, arg ListAuditLogsBySeverityParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsBySeverity, arg.Severity, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByUser = `-- name: ListAuditLogsByUser :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListAuditLogsByUser(ctx context.Context, arg ListAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAuditLogs = `-- name: SearchAuditLogs :many
SELECT id, event_type, event_category, severity, user_id, actor_type, actor_identifier, action, resource_type, resource_id, ip_address, user_agent, request_id, session_id, metadata, previous_state, new_state, status, failure_reason, retention_until, is_sensitive, created_at FROM audit_logs
WHERE 
    ($1::uuid IS NULL OR user_id = $1) AND
    ($2::varchar IS NULL OR event_type = $2) AND
    ($3::varchar IS NULL OR event_category = $3) AND
    ($4::varchar IS NULL OR severity = $4) AND
    ($5::timestamptz IS NULL OR created_at >= $5) AND
    ($6::timestamptz IS NULL OR created_at <= $6)
ORDER BY created_at DESC
LIMIT $7 OFFSET $8
`

type SearchAuditLogsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Column6 time.Time `json:"column_6"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) SearchAuditLogs(ctx context.Context, arg SearchAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, searchAuditLogs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.EventCategory,
			&i.Severity,
			&i.UserID,
			&i.ActorType,
			&i.ActorIdentifier,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.SessionID,
			&i.Metadata,
			&i.PreviousState,
			&i.NewState,
			&i.Status,
			&i.FailureReason,
			&i.RetentionUntil,
			&i.IsSensitive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
